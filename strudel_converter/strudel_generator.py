from dataclasses import dataclass
import re
from pathlib import Path
from typing import List, Optional, Sequence

import librosa
import numpy as np

from .audio_tools import (
    dominant_key,
    export_audio_clip,
    grid_rhythm,
    note_sequence_from_pitch_track,
)


@dataclass
class StrudelResult:
    tempo: float
    root: str
    mode: str
    progression: str
    lead_notes: List[str]
    rhythm: List[str]
    bass_notes: List[str]
    preview_path: Optional[Path]

    def to_code(self) -> str:
        bpm = int(round(self.tempo)) if self.tempo > 0 else 108
        cpm = bpm / 4
        lead_pattern = " ".join(self.lead_notes) if self.lead_notes else "~"
        rhythm_pattern = " ".join(self.rhythm) if self.rhythm else "bd ~ bd ~"
        bass_pattern = " ".join(self.bass_notes) if self.bass_notes else f"{self.root.lower()}2"

        preview_line = (
            f"// preview saved at {self.preview_path}"
            if self.preview_path
            else "// preview clip available once audio is loaded"
        )

        return f"""
// Generated by Strudel Converter
setcpm({cpm:.2f})

// Progression and sections
let prog = chord("<{self.progression}>/4").dict("ireal")
let sections = {{
  drums: arrange(
    [4,  "{rhythm_pattern}"],
    [8,  "{rhythm_pattern}"],
    [4,  "{rhythm_pattern}"],
    [8,  "{rhythm_pattern}"]
  ),
  bass: arrange(
    [4,  "<{bass_pattern}>"],
    [8,  "<{bass_pattern}>"],
    [4,  "<{bass_pattern}>"],
    [8,  "<{bass_pattern}>"]
  ),
  lead: arrange(
    [6,  "~"],
    [8,  "<{lead_pattern}>"],
    [2,  "~"],
    [8,  "<{lead_pattern}>"]
  )
}}

// Drums
let drums =
  sections.drums
    .s()
    .gain(0.95)
    .room(0.12)
    .lpf(9000)
    .stack(sound("hh*4").gain(0.4))

// Bass (roots follow progression)
let bass =
  n(sections.bass)
    .set(prog).mode("root:{self.root.lower()}1")
    .s("sine")
    .attack(0.005).decay(0.14).sustain(0.42).release(0.08)
    .lpf(700).lpq(8)
    .gain(0.82)

// Pad (voicings from progression)
let pad =
  prog.voicing()
    .s("sawtooth")
    .attack(0.01).decay(0.25).sustain(0.6).release(0.2)
    .lpf(1800).lpq(6)
    .room(0.35).roomsize(6)
    .gain(0.35)

// Lead (melody from detected pitches)
let lead =
  n(sections.lead)
    .scale("{self.root}:{self.mode}")
    .s("square")
    .attack(0.01).decay(0.18).sustain(0.2).release(0.12)
    .lpf(2600).lpq(10)
    .delay(0.25).delaytime(0.25).delayfeedback(0.35)
    .room(0.25)
    .gain(0.55)

// Noise riser into drops
let riser =
  arrange(
    [8,  "~"],
    [2,  "white*8"],
    [8,  "~"],
    [2,  "white*8"],
    [4,  "~"],
    [2,  "white*8"]
  ).s()
   .hpf("<200 400 800 1400 2200 3200 4800 6500>")
   .gain(0.12)
   .room(0.2)

// Full mix
stack(drums, pad, bass, lead, riser)

// key: {self.root} {self.mode}
{preview_line}
"""


PITCH_CLASSES = [
    "C",
    "C#",
    "D",
    "D#",
    "E",
    "F",
    "F#",
    "G",
    "G#",
    "A",
    "A#",
    "B",
]


def _format_note(note: str) -> str:
    match = re.match(r"([A-Ga-g][#b♭♯]?)([-]?\d+)", note.strip())
    if not match:
        return note.lower()
    name, octave = match.groups()
    name = name.replace("♯", "#").replace("♭", "b").lower()
    return f"{name}{octave}"


def _transpose(root: str, semitones: int) -> str:
    try:
        idx = PITCH_CLASSES.index(root)
    except ValueError:
        return root
    return PITCH_CLASSES[(idx + semitones) % 12]


def _infer_mode(notes: Sequence[str], root: str) -> str:
    if not notes:
        return "minor"

    try:
        root_pc = librosa.note_to_midi(root + "3") % 12
    except Exception:
        return "minor"

    major_weight = 0
    minor_weight = 0

    for note in notes:
        try:
            pc = librosa.note_to_midi(note) % 12
        except Exception:
            continue
        interval = (pc - root_pc) % 12
        if interval in (3, 10):
            minor_weight += 1
        if interval in (4, 11):
            major_weight += 1

    if minor_weight >= major_weight:
        return "minor"
    return "major"


def _progression(root: str, mode: str) -> str:
    if mode == "major":
        intervals = [
            (0, ""),
            (7, ""),
            (9, "m"),
            (5, ""),
        ]
    else:
        intervals = [
            (0, "m"),
            (8, ""),
            (3, ""),
            (10, ""),
        ]

    chords = []
    for semis, quality in intervals:
        chord_root = _transpose(root, semis)
        chords.append(f"{chord_root}{quality}")
    return " ".join(chords)


def _lead_motif(notes: Sequence[str], root: str) -> List[str]:
    if not notes:
        return [f"{root.lower()}4", f"{_format_note(root + '5')}".lower()]
    cleaned = [_format_note(n) for n in notes if n]
    motif = cleaned[:8]
    while len(motif) < 8 and cleaned:
        motif.append(cleaned[len(motif) % len(cleaned)])
    return motif


def _bass_line(root: str) -> List[str]:
    fifth = _transpose(root, 7)
    octave_root = f"{root.lower()}2"
    octave_fifth = f"{fifth.lower()}2"
    return [octave_root, octave_root, octave_fifth, octave_root]


def build_strudel_result(
    tempo: float,
    chroma: np.ndarray,
    pitches: np.ndarray,
    sr: int,
    onset_times: np.ndarray,
    audio: np.ndarray,
) -> StrudelResult:
    root = dominant_key(chroma)
    notes = note_sequence_from_pitch_track(pitches, sr=sr, onset_times=onset_times)

    if notes:
        counts = {}
        for n in notes:
            counts[n] = counts.get(n, 0) + 1
        notes = sorted(notes, key=lambda x: counts.get(x, 0), reverse=True)

    mode = _infer_mode(notes, root)
    progression = _progression(root, mode)
    lead = _lead_motif(notes, root)
    rhythm = grid_rhythm(onset_times, tempo=tempo)
    bass = _bass_line(root)
    preview = export_audio_clip(audio, sr=sr) if audio.size else None

    return StrudelResult(
        tempo=tempo,
        root=root,
        mode=mode,
        progression=progression,
        lead_notes=lead,
        rhythm=rhythm,
        bass_notes=bass,
        preview_path=preview,
    )
